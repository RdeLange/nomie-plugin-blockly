"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSOrTSDocumentSnapshot = exports.SvelteDocumentSnapshot = exports.DocumentSnapshot = exports.INITIAL_VERSION = void 0;
const trace_mapping_1 = require("@jridgewell/trace-mapping");
const compiler_1 = require("svelte/compiler");
const svelte2tsx_1 = require("svelte2tsx");
const typescript_1 = __importDefault(require("typescript"));
const documents_1 = require("../../lib/documents");
const utils_1 = require("../../utils");
const DocumentMapper_1 = require("./DocumentMapper");
const utils_2 = require("./utils");
/**
 * Initial version of snapshots.
 */
exports.INITIAL_VERSION = 0;
var DocumentSnapshot;
(function (DocumentSnapshot) {
    /**
     * Returns a svelte snapshot from a svelte document.
     * @param document the svelte document
     * @param options options that apply to the svelte document
     */
    function fromDocument(document, options) {
        const { tsxMap, htmlAst, text, exportedNames, parserError, nrPrependedLines, scriptKind } = preprocessSvelteFile(document, options);
        return new SvelteDocumentSnapshot(document, parserError, scriptKind, text, nrPrependedLines, exportedNames, tsxMap, htmlAst);
    }
    DocumentSnapshot.fromDocument = fromDocument;
    /**
     * Returns a svelte or ts/js snapshot from a file path, depending on the file contents.
     * @param filePath path to the js/ts/svelte file
     * @param createDocument function that is used to create a document in case it's a Svelte file
     * @param options options that apply in case it's a svelte file
     */
    function fromFilePath(filePath, createDocument, options, tsSystem) {
        if ((0, utils_2.isSvelteFilePath)(filePath)) {
            return DocumentSnapshot.fromSvelteFilePath(filePath, createDocument, options);
        }
        else {
            return DocumentSnapshot.fromNonSvelteFilePath(filePath, tsSystem);
        }
    }
    DocumentSnapshot.fromFilePath = fromFilePath;
    /**
     * Returns a ts/js snapshot from a file path.
     * @param filePath path to the js/ts file
     * @param options options that apply in case it's a svelte file
     */
    function fromNonSvelteFilePath(filePath, tsSystem) {
        let originalText = '';
        // The following (very hacky) code makes sure that the ambient module definitions
        // that tell TS "every import ending with .svelte is a valid module" are removed.
        // They exist in svelte2tsx and svelte to make sure that people don't
        // get errors in their TS files when importing Svelte files and not using our TS plugin.
        // If someone wants to get back the behavior they can add an ambient module definition
        // on their own.
        const normalizedPath = filePath.replace(/\\/g, '/');
        if (!normalizedPath.endsWith('node_modules/svelte/types/runtime/ambient.d.ts')) {
            originalText = tsSystem.readFile(filePath) || '';
        }
        if (normalizedPath.endsWith('svelte2tsx/svelte-shims.d.ts') ||
            normalizedPath.endsWith('svelte-check/dist/src/svelte-shims.d.ts')) {
            // If not present, the LS uses an older version of svelte2tsx
            if (originalText.includes('// -- start svelte-ls-remove --')) {
                originalText =
                    originalText.substring(0, originalText.indexOf('// -- start svelte-ls-remove --')) +
                        originalText.substring(originalText.indexOf('// -- end svelte-ls-remove --'));
            }
        }
        return new JSOrTSDocumentSnapshot(exports.INITIAL_VERSION, filePath, originalText);
    }
    DocumentSnapshot.fromNonSvelteFilePath = fromNonSvelteFilePath;
    /**
     * Returns a svelte snapshot from a file path.
     * @param filePath path to the svelte file
     * @param createDocument function that is used to create a document
     * @param options options that apply in case it's a svelte file
     */
    function fromSvelteFilePath(filePath, createDocument, options) {
        var _a;
        const originalText = (_a = typescript_1.default.sys.readFile(filePath)) !== null && _a !== void 0 ? _a : '';
        return fromDocument(createDocument(filePath, originalText), options);
    }
    DocumentSnapshot.fromSvelteFilePath = fromSvelteFilePath;
})(DocumentSnapshot = exports.DocumentSnapshot || (exports.DocumentSnapshot = {}));
/**
 * Tries to preprocess the svelte document and convert the contents into better analyzable js/ts(x) content.
 */
function preprocessSvelteFile(document, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    let tsxMap;
    let parserError = null;
    let nrPrependedLines = 0;
    let text = document.getText();
    let exportedNames = { has: () => false };
    let htmlAst;
    const scriptKind = [
        (0, utils_2.getScriptKindFromAttributes)((_b = (_a = document.scriptInfo) === null || _a === void 0 ? void 0 : _a.attributes) !== null && _b !== void 0 ? _b : {}),
        (0, utils_2.getScriptKindFromAttributes)((_d = (_c = document.moduleScriptInfo) === null || _c === void 0 ? void 0 : _c.attributes) !== null && _d !== void 0 ? _d : {})
    ].includes(typescript_1.default.ScriptKind.TSX)
        ? options.useNewTransformation
            ? typescript_1.default.ScriptKind.TS
            : typescript_1.default.ScriptKind.TSX
        : options.useNewTransformation
            ? typescript_1.default.ScriptKind.JS
            : typescript_1.default.ScriptKind.JSX;
    try {
        const tsx = (0, svelte2tsx_1.svelte2tsx)(text, {
            filename: (_e = document.getFilePath()) !== null && _e !== void 0 ? _e : undefined,
            isTsFile: options.useNewTransformation
                ? scriptKind === typescript_1.default.ScriptKind.TS
                : scriptKind === typescript_1.default.ScriptKind.TSX,
            mode: options.useNewTransformation ? 'ts' : 'tsx',
            typingsNamespace: options.useNewTransformation ? options.typingsNamespace : undefined,
            emitOnTemplateError: options.transformOnTemplateError,
            namespace: (_g = (_f = document.config) === null || _f === void 0 ? void 0 : _f.compilerOptions) === null || _g === void 0 ? void 0 : _g.namespace,
            accessors: (_k = (_j = (_h = document.config) === null || _h === void 0 ? void 0 : _h.compilerOptions) === null || _j === void 0 ? void 0 : _j.accessors) !== null && _k !== void 0 ? _k : (_m = (_l = document.config) === null || _l === void 0 ? void 0 : _l.compilerOptions) === null || _m === void 0 ? void 0 : _m.customElement
        });
        text = tsx.code;
        tsxMap = tsx.map;
        exportedNames = tsx.exportedNames;
        // We know it's there, it's not part of the public API so people don't start using it
        htmlAst = tsx.htmlAst;
        if (tsxMap) {
            tsxMap.sources = [document.uri];
            const scriptInfo = document.scriptInfo || document.moduleScriptInfo;
            const tsCheck = (0, utils_2.getTsCheckComment)(scriptInfo === null || scriptInfo === void 0 ? void 0 : scriptInfo.content);
            if (tsCheck) {
                text = tsCheck + text;
                nrPrependedLines = 1;
            }
        }
    }
    catch (e) {
        // Error start/end logic is different and has different offsets for line, so we need to convert that
        const start = {
            line: ((_p = (_o = e.start) === null || _o === void 0 ? void 0 : _o.line) !== null && _p !== void 0 ? _p : 1) - 1,
            character: (_r = (_q = e.start) === null || _q === void 0 ? void 0 : _q.column) !== null && _r !== void 0 ? _r : 0
        };
        const end = e.end ? { line: e.end.line - 1, character: e.end.column } : start;
        parserError = {
            range: { start, end },
            message: e.message,
            code: -1
        };
        // fall back to extracted script, if any
        const scriptInfo = document.scriptInfo || document.moduleScriptInfo;
        text = scriptInfo ? scriptInfo.content : '';
    }
    return {
        tsxMap,
        text,
        exportedNames,
        htmlAst,
        parserError,
        nrPrependedLines,
        scriptKind
    };
}
/**
 * A svelte document snapshot suitable for the TS language service and the plugin.
 * It contains the generated code (Svelte->TS/JS) so the TS language service can understand it.
 */
class SvelteDocumentSnapshot {
    constructor(parent, parserError, scriptKind, text, nrPrependedLines, exportedNames, tsxMap, htmlAst) {
        this.parent = parent;
        this.parserError = parserError;
        this.scriptKind = scriptKind;
        this.text = text;
        this.nrPrependedLines = nrPrependedLines;
        this.exportedNames = exportedNames;
        this.tsxMap = tsxMap;
        this.htmlAst = htmlAst;
        this.url = (0, utils_1.pathToUrl)(this.filePath);
        this.version = this.parent.version;
    }
    get filePath() {
        return this.parent.getFilePath() || '';
    }
    get scriptInfo() {
        return this.parent.scriptInfo;
    }
    get moduleScriptInfo() {
        return this.parent.moduleScriptInfo;
    }
    getOriginalText(range) {
        return this.parent.getText(range);
    }
    getText(start, end) {
        return this.text.substring(start, end);
    }
    getLength() {
        return this.text.length;
    }
    getFullText() {
        return this.text;
    }
    getChangeRange() {
        return undefined;
    }
    positionAt(offset) {
        return (0, documents_1.positionAt)(offset, this.text, this.getLineOffsets());
    }
    offsetAt(position) {
        return (0, documents_1.offsetAt)(position, this.text, this.getLineOffsets());
    }
    getLineContainingOffset(offset) {
        const chunks = this.getText(0, offset).split('\n');
        return chunks[chunks.length - 1];
    }
    hasProp(name) {
        return this.exportedNames.has(name);
    }
    svelteNodeAt(postionOrOffset) {
        if (!this.htmlAst) {
            return null;
        }
        const offset = typeof postionOrOffset === 'number'
            ? postionOrOffset
            : this.parent.offsetAt(postionOrOffset);
        let foundNode = null;
        (0, compiler_1.walk)(this.htmlAst, {
            enter(node) {
                // In case the offset is at a point where a node ends and a new one begins,
                // the node where the code ends is used. If this introduces problems, introduce
                // an affinity parameter to prefer the node where it ends/starts.
                if (node.start > offset || node.end < offset) {
                    this.skip();
                    return;
                }
                const parent = foundNode;
                // Spread so the "parent" property isn't added to the original ast,
                // causing an infinite loop
                foundNode = { ...node };
                if (parent) {
                    foundNode.parent = parent;
                }
            }
        });
        return foundNode;
    }
    getOriginalPosition(pos) {
        return this.getMapper().getOriginalPosition(pos);
    }
    getGeneratedPosition(pos) {
        return this.getMapper().getGeneratedPosition(pos);
    }
    isInGenerated(pos) {
        return !(0, documents_1.isInTag)(pos, this.parent.styleInfo);
    }
    getURL() {
        return this.url;
    }
    getLineOffsets() {
        if (!this.lineOffsets) {
            this.lineOffsets = (0, documents_1.getLineOffsets)(this.text);
        }
        return this.lineOffsets;
    }
    getMapper() {
        if (!this.mapper) {
            this.mapper = this.initMapper();
        }
        return this.mapper;
    }
    initMapper() {
        const scriptInfo = this.parent.scriptInfo || this.parent.moduleScriptInfo;
        if (!this.tsxMap) {
            if (!scriptInfo) {
                return new documents_1.IdentityMapper(this.url);
            }
            return new documents_1.FragmentMapper(this.parent.getText(), scriptInfo, this.url);
        }
        return new DocumentMapper_1.ConsumerDocumentMapper(new trace_mapping_1.TraceMap(this.tsxMap), this.url, this.nrPrependedLines);
    }
}
exports.SvelteDocumentSnapshot = SvelteDocumentSnapshot;
/**
 * A js/ts document snapshot suitable for the ts language service and the plugin.
 * Since no mapping has to be done here, it also implements the mapper interface.
 */
class JSOrTSDocumentSnapshot extends documents_1.IdentityMapper {
    constructor(version, filePath, text) {
        super((0, utils_1.pathToUrl)(filePath));
        this.version = version;
        this.filePath = filePath;
        this.text = text;
        this.scriptKind = (0, utils_2.getScriptKindFromFileName)(this.filePath);
        this.scriptInfo = null;
    }
    getText(start, end) {
        return this.text.substring(start, end);
    }
    getLength() {
        return this.text.length;
    }
    getFullText() {
        return this.text;
    }
    getChangeRange() {
        return undefined;
    }
    positionAt(offset) {
        return (0, documents_1.positionAt)(offset, this.text, this.getLineOffsets());
    }
    offsetAt(position) {
        return (0, documents_1.offsetAt)(position, this.text, this.getLineOffsets());
    }
    update(changes) {
        for (const change of changes) {
            let start = 0;
            let end = 0;
            if ('range' in change) {
                start = this.offsetAt(change.range.start);
                end = this.offsetAt(change.range.end);
            }
            else {
                end = this.getLength();
            }
            this.text = this.text.slice(0, start) + change.text + this.text.slice(end);
        }
        this.version++;
        this.lineOffsets = undefined;
    }
    getLineOffsets() {
        if (!this.lineOffsets) {
            this.lineOffsets = (0, documents_1.getLineOffsets)(this.text);
        }
        return this.lineOffsets;
    }
}
exports.JSOrTSDocumentSnapshot = JSOrTSDocumentSnapshot;
//# sourceMappingURL=DocumentSnapshot.js.map