"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SvelteCheck = void 0;
const path_1 = require("path");
const typescript_1 = __importDefault(require("typescript"));
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("./lib/documents");
const FileSystemProvider_1 = require("./plugins/css/FileSystemProvider");
const logger_1 = require("./logger");
const ls_config_1 = require("./ls-config");
const plugins_1 = require("./plugins");
const service_1 = require("./plugins/css/service");
const utils_1 = require("./plugins/typescript/utils");
const utils_2 = require("./utils");
/**
 * Small wrapper around PluginHost's Diagnostic Capabilities
 * for svelte-check, without the overhead of the lsp.
 */
class SvelteCheck {
    constructor(workspacePath, options = {}) {
        this.options = options;
        this.docManager = new documents_1.DocumentManager((textDocument) => new documents_1.Document(textDocument.uri, textDocument.text));
        this.configManager = new ls_config_1.LSConfigManager();
        this.pluginHost = new plugins_1.PluginHost(this.docManager);
        logger_1.Logger.setLogErrorsOnly(true);
        this.initialize(workspacePath, options);
    }
    async initialize(workspacePath, options) {
        var _a;
        if (options.tsconfig && !(0, path_1.isAbsolute)(options.tsconfig)) {
            throw new Error('tsconfigPath needs to be absolute, got ' + options.tsconfig);
        }
        this.configManager.update({
            svelte: {
                compilerWarnings: options.compilerWarnings,
                useNewTransformation: (_a = options.useNewTransformation) !== null && _a !== void 0 ? _a : false
            }
        });
        // No HTMLPlugin, it does not provide diagnostics
        if (shouldRegister('svelte')) {
            this.pluginHost.register(new plugins_1.SveltePlugin(this.configManager));
        }
        if (shouldRegister('css')) {
            const services = (0, service_1.createLanguageServices)({
                fileSystemProvider: new FileSystemProvider_1.FileSystemProvider()
            });
            const workspaceFolders = [
                {
                    name: '',
                    uri: (0, utils_2.pathToUrl)(workspacePath)
                }
            ];
            this.pluginHost.register(new plugins_1.CSSPlugin(this.docManager, this.configManager, workspaceFolders, services));
        }
        if (shouldRegister('js') || options.tsconfig) {
            this.lsAndTSDocResolver = new plugins_1.LSAndTSDocResolver(this.docManager, [(0, utils_2.pathToUrl)(workspacePath)], this.configManager, {
                tsconfigPath: options.tsconfig,
                isSvelteCheck: true,
                onProjectReloaded: options.onProjectReload,
                watchTsConfig: options.watch
            });
            this.pluginHost.register(new plugins_1.TypeScriptPlugin(this.configManager, this.lsAndTSDocResolver));
        }
        function shouldRegister(source) {
            return !options.diagnosticSources || options.diagnosticSources.includes(source);
        }
    }
    /**
     * Creates/updates given document
     *
     * @param doc Text and Uri of the document
     * @param isNew Whether or not this is the creation of the document
     */
    async upsertDocument(doc, isNew) {
        const filePath = (0, utils_2.urlToPath)(doc.uri) || '';
        if (isNew && this.options.tsconfig) {
            const lsContainer = await this.getLSContainer(this.options.tsconfig);
            if (!lsContainer.fileBelongsToProject(filePath)) {
                return;
            }
        }
        if (doc.uri.endsWith('.ts') || doc.uri.endsWith('.js')) {
            this.pluginHost.updateTsOrJsFile(filePath, [
                {
                    range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(0, 0), vscode_languageserver_1.Position.create(Number.MAX_VALUE, Number.MAX_VALUE)),
                    text: doc.text
                }
            ]);
        }
        else {
            this.docManager.openDocument({
                text: doc.text,
                uri: doc.uri
            });
            this.docManager.markAsOpenedInClient(doc.uri);
        }
    }
    /**
     * Removes/closes document
     *
     * @param uri Uri of the document
     */
    async removeDocument(uri) {
        if (!this.docManager.get(uri)) {
            return;
        }
        this.docManager.closeDocument(uri);
        this.docManager.releaseDocument(uri);
        if (this.options.tsconfig) {
            const lsContainer = await this.getLSContainer(this.options.tsconfig);
            lsContainer.deleteSnapshot((0, utils_2.urlToPath)(uri) || '');
        }
    }
    /**
     * Gets the diagnostics for all currently open files.
     */
    async getDiagnostics() {
        if (this.options.tsconfig) {
            return this.getDiagnosticsForTsconfig(this.options.tsconfig);
        }
        return await Promise.all(this.docManager.getAllOpenedByClient().map(async (doc) => {
            const uri = doc[1].uri;
            return await this.getDiagnosticsForFile(uri);
        }));
    }
    async getDiagnosticsForTsconfig(tsconfigPath) {
        var _a, _b;
        const lsContainer = await this.getLSContainer(tsconfigPath);
        const lang = lsContainer.getService();
        const files = ((_a = lang.getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFiles()) || [];
        const options = ((_b = lang.getProgram()) === null || _b === void 0 ? void 0 : _b.getCompilerOptions()) || {};
        return await Promise.all(files.map((file) => {
            const uri = (0, utils_2.pathToUrl)(file.fileName);
            const doc = this.docManager.get(uri);
            if (doc) {
                this.docManager.markAsOpenedInClient(uri);
                return this.getDiagnosticsForFile(uri);
            }
            else {
                // This check is done inside TS mostly, too, but for some diagnostics like suggestions it
                // doesn't apply to all code paths. That's why we do it here, too.
                const skipDiagnosticsForFile = (options.skipLibCheck && file.isDeclarationFile) ||
                    (options.skipDefaultLibCheck && file.hasNoDefaultLib) ||
                    // ignore JS files in node_modules
                    /\/node_modules\/.+\.(c|m)?js$/.test(file.fileName);
                const diagnostics = skipDiagnosticsForFile
                    ? []
                    : [
                        ...lang.getSyntacticDiagnostics(file.fileName),
                        ...lang.getSuggestionDiagnostics(file.fileName),
                        ...lang.getSemanticDiagnostics(file.fileName)
                    ].map((diagnostic) => ({
                        range: (0, utils_1.convertRange)({ positionAt: file.getLineAndCharacterOfPosition.bind(file) }, diagnostic),
                        severity: (0, utils_1.mapSeverity)(diagnostic.category),
                        source: diagnostic.source,
                        message: typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, '\n'),
                        code: diagnostic.code,
                        tags: (0, utils_1.getDiagnosticTag)(diagnostic)
                    }));
                return {
                    filePath: file.fileName,
                    text: file.text,
                    diagnostics
                };
            }
        }));
    }
    async getDiagnosticsForFile(uri) {
        var _a;
        const diagnostics = await this.pluginHost.getDiagnostics({ uri });
        return {
            filePath: (0, utils_2.urlToPath)(uri) || '',
            text: ((_a = this.docManager.get(uri)) === null || _a === void 0 ? void 0 : _a.getText()) || '',
            diagnostics
        };
    }
    getLSContainer(tsconfigPath) {
        if (!this.lsAndTSDocResolver) {
            throw new Error('Cannot run with tsconfig path without LS/TSdoc resolver');
        }
        return this.lsAndTSDocResolver.getTSService(tsconfigPath);
    }
}
exports.SvelteCheck = SvelteCheck;
//# sourceMappingURL=svelte-check.js.map